## Objectives

- Explain what a promise is.
- Explain why a promise is important.
- Send an HTTP request from Node.js with a promise.

## What's a promise?

In Node.js, it's possible to start an I/O operation and then continue with other operations that don't require the I/O to be completed. This approach is called **asynchronous** or **non-blocking** I/O. Any tasks that depend on the I/O operation to be completed still need to wait and are thus blocked. But other operations that don't have a dependency on the I/O operation can continue.

All asynchronous I/O operations that are core to Node.js invoke a callback function when it completes. For example, here's a short program that appends content to a file using the `fs` core module.

```javascript
'use strict';

const fs = require('fs');
const filePath = 'hello.txt';
const content = 'Hello callback\n';

fs.appendFile(filePath, content, (err) => {
  if (err) {
    console.error(err);
    process.exit(1);
  }

  console.log(content);
});

console.log('Waiting for the asynchronous I/O operation to complete...');
```

Asynchronous I/O operations that are core to Node.js, like `fs.appendFile()`, always take a completion callback as the last argument. Any exceptions generated by the operation are passed to the callback's first argument. In the above example, an error would be passed to the callback if the program didn't have the correct permissions to access the file. When the I/O operation completes successfully, the callback's first argument is `null`. The callback may have other arguments, but it depends on the specific asynchronous method.

Another way to perform an asynchronous I/O operation is with a more sophisticated coding construct called a promise. A **promise** is an object that represents an asynchronous operation that hasn't completed yet, but will in the future. When a promise is instantiated, it starts off in a pending state and given an `executor` callback function. The callback takes two arguments—a `resolve` function and `reject` function.

The first argument fulfills the promise, the second argument rejects it. We can call these functions once our operation is completed.

```javascript
'use strict';

const fs = require('fs');
const filePath = 'hello.txt';
const content = 'Hello promise\n';

const promise = new Promise((resolve, reject) => {
  fs.appendFile(filePath, content, (err) => {
    if (err) {
      return reject(err);
    }

    resolve(content);
  });
});

promise.then((content) => {
  console.log(content);
});

promise.catch((err) => {
  console.error(err);
  process.exit(1);
});

console.log('Waiting for the asynchronous I/O operation to complete...');
```

For example, the `$xhr` promise remains unresolved while it waits for the HTTP response. The `$xhr` promise has two methods, `done()` and `fail()`, that are given a callback each. If the HTTP response is successful, the `done()` function's callback is triggered. On the other hand, if the HTTP response generates an error, the `fail()` function's callback is triggered.

```text
┌── new Promise(executor) ──┐                  ┌── then(onFulfilled) ──┐
│                           │                  │                       │
│                           │───── fulfill ───▶│                       │
│                           │                  │                       │
│                           │                  │                       │
│                           │                  └───────────────────────┘
│          Pending          │
│                           │                  ┌── catch(onRejected) ──┐
│                           │                  │                       │
│                           │                  │                       │
│                           │───── reject ────▶│                       │
│                           │                  │                       │
└───────────────────────────┘                  └───────────────────────┘
```

Just like how jQuery uses a promise to handle an HTTP response from an HTTP server, Knex uses promises to handle a SQL response from a PostgreSQL server. In fact, nearly all the functions in Knex return a promise as the preferred way of handling SQL responses. The main difference from jQuery is that Knex promises use the `then()` and `catch()` asynchronous functions instead of `done()` and `fail()`.

**NOTE:** jQuery 3.0 has switched over to use the `then()` and `catch()` functions as well.

These two arguments are functions which tell the promise how it should branch and allow you to return different values. For example, let's have a promise simply check to see if a number is odd or not. Open up a node repl and paste in the following code.

### Exercise

Turn to a neighbor and explain what a promise is and how it works in your own words. Then, diagram how a promise works.

## Why is a promise important?

The main benefit of a promise is its ability to separate the success handling logic from the error handling logic.

```javascript
'use strict';

const fs = require('fs');
const filePath = 'hello.txt';
const content = 'Hello promise\n';

const promise = new Promise((resolve, reject) => {
  fs.appendFile(filePath, content, (err) => {
    if (err) {
      return reject(err);
    }

    resolve(content);
  });
});

promise
  .then((content) => {
    console.log(content);
  })
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });

console.log('Waiting for the asynchronous I/O operation to complete...');
```

```text
┌── new Promise(executor) ──┐                  ┌── then(onFulfilled) ──┐                    ┌────── new Promise() ──────┐
│                           │                  │                       │────── fulfill ────▶│                           │
│                           │───── fulfill ───▶│                       │       return       │                           │
│                           │                  │                       │                    │                           │
│                           │                  │                       │────── reject ─────▶│                           │
│                           │                  └───────────────────────┘       throw        │                           │
│          Pending          │                                                               │                           │
│                           │                  ┌── catch(onRejected) ──┐                    │                           │
│                           │                  │                       │────── fulfill ────▶│                           │
│                           │                  │                       │       return       │                           │
│                           │───── reject ────▶│                       │                    │                           │
│                           │                  │                       │────── reject ─────▶│                           │
└───────────────────────────┘                  └───────────────────────┘       throw        └───────────────────────────┘
```

```javascript
'use strict';

const fs = require('fs');
const filePath = 'hello.txt';
const content = 'Hello promise\n';

const promise = new Promise((resolve, reject) => {
  fs.appendFile(filePath, content, (err) => {
    if (err) {
      return reject(err);
    }

    resolve(content);
  });
});

promise
  .then((content) => {
    return content.toUpperCase();
  })
  .then((content) => {
    console.log(content);
  })
  .catch((err) => {
    console.error(err);
    throw err;
  })
  .catch((err) => {
    process.exit(1);
  });

console.log('Waiting for the asynchronous I/O operation to complete...');
```

### Exercise

Turn to a neighbor and explain why a promise is important. Then, diagram how a promise chaining works.

## How do you send an HTTP request from Node.js with a promise?

```shell
mkdir promises
cd promises
```

```shell
npm init
npm install --save request
```

```javascript
'use strict';

const request = require('request');

const getJSON = function(url) {
  const promise = new Promise((resolve, reject) => {
    request.get(url, (err, res, body) => {
      if (err) {
        return reject(err);
      }

      resolve(JSON.parse(body));
    });
  });

  return promise;
};

getJSON('http://www.omdbapi.com/?s=Captain%20America')
  .then((body) => {
    console.log(body);
  })
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });
```

```javascript
'use strict';

const request = require('request');

const getJSON = function(url) {
  const promise = new Promise((resolve, reject) => {
    request.get(url, (err, res, body) => {
      if (err) {
        return reject(err);
      }

      resolve(JSON.parse(body));
    });
  });

  return promise;
};

getJSON('http://www.omdbapi.com/?s=Captain%20America')
  .then((body) => {
    return getJSON(`http://www.omdbapi.com/?i=${body.Search[0].imdbID}`);
  })
  .then((body) => {
    console.log(body);
  })
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });

```

## Assignment

- [Promise Fundamentals](https://github.com/gSchool/wd-promise-fundamentals)

## Resources

- [Introduction to ES6 Promises](http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/)
- [Mozilla Developer Network - Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
- [Promises Unwrapping - States and Fates](https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md)
- [Promises - In Wicked Detail](http://www.mattgreer.org/articles/promises-in-wicked-detail/)
- [Promises/A+ Standard](https://promisesaplus.com/)
- [We have a problem with promises](http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html)

## Videos

### Nested / Chained Promises

**ERRATA:** There's an error at 3:55. The bottom function box should read "f2".

<iframe src="https://player.vimeo.com/video/136801594?byline=0&portrait=0" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

### `Promise.all`

<iframe src="https://player.vimeo.com/video/136900546?byline=0&portrait=0" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
