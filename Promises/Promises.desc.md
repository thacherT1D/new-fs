## Objectives

- Explain what a promise is.
- Explain why a promise is important.
- Send an HTTP request from Node.js with a promise.

## What's a promise?

In Node.js, it's possible to start an I/O operation and then continue with other operations that don't require the I/O to be completed. This approach is called **asynchronous** or **non-blocking** I/O. Any tasks that depend on the I/O operation to be completed still need to wait and are thus blocked. But other operations that don't have a dependency on the I/O operation can continue.

For example, the following `appendContent.js` program appends content to a file using the `fs` core module.

```javascript
'use strict';

const fs = require('fs');
const filePath = 'hello.txt';
const content = 'Hello callback\n';

fs.appendFile(filePath, content, (err) => {
  if (err) {
    console.error(err);
    process.exit(1);
  }

  console.log(content);
});

console.log('Waiting for the asynchronous I/O operation to complete...');
```

Execute the program.

```shell
node appendContent.js
```

And you should see something like this.

```text
Waiting for the asynchronous I/O operation to complete...
Hello callback
```

All asynchronous I/O operations that are core to Node.js, like the `fs.appendFile()` method, invoke a callback function when completed. If the operation completes successfully, the callback's first argument is `null`. However, any exceptions generated by the operation, like an insufficient file permissions error, are passed to the callback's first argument.

Remove the user's write permission from the `hello.text` file.

```shell
chmod u-w hello.txt
```

And execute the program again.

```shell
node appendContent.js
```

And you should see something like this.

```text
Waiting for the asynchronous I/O operation to complete...
{ Error: EACCES: permission denied, open 'hello.txt'
    at Error (native) errno: -13, code: 'EACCES', syscall: 'open', path: 'hello.txt' }
```

Another way to perform an asynchronous I/O operation is with a more sophisticated coding construct called a promise. A **promise** is an object that represents an asynchronous operation that hasn't completed yet, but will in the future. As an object, a promise has the following three possible states.

1. Pending
1. Fulfilled
1. Rejected

**NOTE:** A promise can only be in one state at time.

A newly instantiated promise starts off in the pending state and is given an `executor` callback function. Like a traditional asynchronous I/O operation, the callback is registered with the event loop and is automatically invoked when the currently executing call stack is finished. However, unlike a traditional asynchronous I/O operation, the `executor` callback is invoked with two arguments—a `resolve` function and a `reject` function.

The following `appendContentPromise.js` program appends content to a file using the `fs` core module. It performs the exact same asynchronous I/O operation as before, only this time it's wrapped inside the `executor` callback function of a promise.

```javascript
'use strict';

const fs = require('fs');
const filePath = 'hello.txt';
const content = 'Hello promise\n';

const promise = new Promise((resolve, reject) => {
  fs.appendFile(filePath, content, (err) => {
    if (err) {
      return reject(err);
    }

    resolve(content);
  });
});

promise.then((content) => {
  console.log(content);
});

promise.catch((err) => {
  console.error(err);
  process.exit(1);
});

console.log('Waiting for the asynchronous I/O operation to complete...');
```

Execute the program.

```shell
node appendContentPromise.js
```

And you should see something like this.

```text
Waiting for the asynchronous I/O operation to complete...
{ Error: EACCES: permission denied, open 'hello.txt'
    at Error (native) errno: -13, code: 'EACCES', syscall: 'open', path: 'hello.txt' }
```

Add the user's write permission back to the `hello.text` file.

```shell
chmod u+w hello.txt
```

And execute the program again.

```shell
node appendContentPromise.js
```

And you should see something like this.

```text
Waiting for the asynchronous I/O operation to complete...
Hello promise
```

As you can see, the role of the `executor` callback function is to start an asynchronous I/O operation. If the operation generates an error, the callback invokes the `reject()` function, passing along the error, which permanently changes the state of the promise to rejected. Otherwise, the `resolve()` function is invoked, passing along the results of the operation, which permanently resolves the state of the promise to either rejected or fulfilled. If resolving the promise generates a new error, the state is changed to rejected, otherwise it's changed to fulfilled.


```text
┌── new Promise(executor) ──┐                  ┌── then(onFulfilled) ──┐
│                           │                  │                       │
│                           │───── fulfill ───▶│                       │
│                           │                  │                       │
│                           │                  │                       │
│                           │                  └───────────────────────┘
│          Pending          │
│                           │                  ┌── catch(onRejected) ──┐
│                           │                  │                       │
│                           │                  │                       │
│                           │───── reject ────▶│                       │
│                           │                  │                       │
└───────────────────────────┘                  └───────────────────────┘
```

Just like how jQuery uses a promise to handle an HTTP response from an HTTP server, Knex uses promises to handle a SQL response from a PostgreSQL server. In fact, nearly all the functions in Knex return a promise as the preferred way of handling SQL responses. The main difference from jQuery is that Knex promises use the `then()` and `catch()` asynchronous functions instead of `done()` and `fail()`.

**NOTE:** jQuery 3.0 has switched over to use the `then()` and `catch()` functions as well.

These two arguments are functions which tell the promise how it should branch and allow you to return different values. For example, let's have a promise simply check to see if a number is odd or not. Open up a node repl and paste in the following code.

### Exercise

Turn to a neighbor and explain what a promise is and how it works in your own words. Then, diagram how a promise works.

## Why is a promise important?

The main benefit of a promise is its ability to separate the success handling logic from the error handling logic.

```javascript
'use strict';

const fs = require('fs');
const filePath = 'hello.txt';
const content = 'Hello promise\n';

const promise = new Promise((resolve, reject) => {
  fs.appendFile(filePath, content, (err) => {
    if (err) {
      return reject(err);
    }

    resolve(content);
  });
});

promise
  .then((content) => {
    console.log(content);
  })
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });

console.log('Waiting for the asynchronous I/O operation to complete...');
```

```text
┌── new Promise(executor) ──┐                  ┌── then(onFulfilled) ──┐                    ┌────── new Promise() ──────┐
│                           │                  │                       │────── fulfill ────▶│                           │
│                           │───── fulfill ───▶│                       │       return       │                           │
│                           │                  │                       │                    │                           │
│                           │                  │                       │────── reject ─────▶│                           │
│                           │                  └───────────────────────┘       throw        │                           │
│          Pending          │                                                               │                           │
│                           │                  ┌── catch(onRejected) ──┐                    │                           │
│                           │                  │                       │────── fulfill ────▶│                           │
│                           │                  │                       │       return       │                           │
│                           │───── reject ────▶│                       │                    │                           │
│                           │                  │                       │────── reject ─────▶│                           │
└───────────────────────────┘                  └───────────────────────┘       throw        └───────────────────────────┘
```

```javascript
'use strict';

const fs = require('fs');
const filePath = 'hello.txt';
const content = 'Hello promise\n';

const promise = new Promise((resolve, reject) => {
  fs.appendFile(filePath, content, (err) => {
    if (err) {
      return reject(err);
    }

    resolve(content);
  });
});

promise
  .then((content) => {
    return content.toUpperCase();
  })
  .then((content) => {
    console.log(content);
  })
  .catch((err) => {
    console.error(err);
    throw err;
  })
  .catch((err) => {
    process.exit(1);
  });

console.log('Waiting for the asynchronous I/O operation to complete...');
```

### Exercise

Turn to a neighbor and explain why a promise is important. Then, diagram how a promise chaining works.

## How do you send an HTTP request from Node.js with a promise?

```shell
mkdir promises
cd promises
```

```shell
npm init
npm install --save request
```

```javascript
'use strict';

const request = require('request');

const getJSON = function(url) {
  const promise = new Promise((resolve, reject) => {
    request.get(url, (err, res, body) => {
      if (err) {
        return reject(err);
      }

      resolve(JSON.parse(body));
    });
  });

  return promise;
};

getJSON('http://www.omdbapi.com/?s=Captain%20America')
  .then((body) => {
    console.log(body);
  })
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });
```

```javascript
'use strict';

const request = require('request');

const getJSON = function(url) {
  const promise = new Promise((resolve, reject) => {
    request.get(url, (err, res, body) => {
      if (err) {
        return reject(err);
      }

      resolve(JSON.parse(body));
    });
  });

  return promise;
};

getJSON('http://www.omdbapi.com/?s=Captain%20America')
  .then((body) => {
    return getJSON(`http://www.omdbapi.com/?i=${body.Search[0].imdbID}`);
  })
  .then((body) => {
    console.log(body);
  })
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });

```

## Assignment

- [Promise Fundamentals](https://github.com/gSchool/wd-promise-fundamentals)

## Resources

- [Introduction to ES6 Promises](http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/)
- [Mozilla Developer Network - Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
- [Promises Unwrapping - States and Fates](https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md)
- [Promises - In Wicked Detail](http://www.mattgreer.org/articles/promises-in-wicked-detail/)
- [Promises/A+ Standard](https://promisesaplus.com/)
- [We have a problem with promises](http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html)

## Videos

### Nested / Chained Promises

**ERRATA:** There's an error at 3:55. The bottom function box should read "f2".

<iframe src="https://player.vimeo.com/video/136801594?byline=0&portrait=0" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

### `Promise.all`

<iframe src="https://player.vimeo.com/video/136900546?byline=0&portrait=0" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
