# MongoDB and CRUD

## Objectives

- Explain when you'd use a NoSQL database over a relational one and why MongoDB is popular
- Compare and contrast MongoDB to PostgreSQL
- Build an API using MongoDB and Monk as the datastore

## The "M" in MEAN Stack

MongoDB and, more generally, NoSQL databases have risen to recent prominence as the scale of data generated by users of the world wide web has grown, though it is worth noting that NoSQL databases and document stores are not new concepts.

MongoDB is an easy choice to begin working with because JSON is stored into and read from MongoDB's storage format, BSON. Additionally, the schemaless nature is seen as an early advantage because you don't have to plan what the documents in a collection will hold, you can just store documents with different properties. This makes it extremely easy to get up and running with a datastore with little overhead or foresight.

However, there are very few use cases that work with truly non-relational data. Additionally, MongoDB's complexity (and the code to interface with it) increases considerably as your application grows and changes.

## MongoDB vs PostgreSQL

We'll install MongoDB just like we did PostgreSQL, with Brew. On the terminal run `brew install mongodb`. We configured the actual PostgreSQL server process to always run on our machines since we used it so much; we could do that with MongoDB but since we aren't planning on using it all the time, we just manually start the server process by running `mongod` in a terminal window. Make sure not to end the process or you'll stop your database server.

In MongoDB, all of your data is stored in collections as individual documents. These echo the concepts of tables and rows in a sql database. However, collections don't have an explicitly defined schema and documents are generally nested to relate to each other instead of being joined.

After the server process is running, you can use `mongo` to access a CLI for the database (like running `psql`). Some of the common commands you may use are listing databases, connecting to a database, listing collections in a db, and starting to query the data. You can use the following commands for those use cases in the cli: (In all the following examples, replace `<collection>` with the actual name of the collection you're working with.)

- list databases: `show dbs`
- connect to db: `use <dbname>`
- list collections in a db `show collections`
- select all documents in a collection `db.<collection>.find()`

CRUD statements in MongoDB are pretty straightforward as well

- Create: `db.<collection>.insert()`
- Read: `db.<collection>.find()`
- Update: `db.<collection>.update()`
- Delete: `db.<collection>.remove()`

Except for delete, all these methods accept an object that describes the document to insert or describes how to match the documents in the collection. For example, running `db.users.find({age:21})` would find all the user documents that have a property age that is 21. The update method takes three arguments, an object to use to match documents, another object describing the changes to be made, and then finally an optional object describing the update.

Instead of using various functions or keywords like SQL, MongoDB uses operators for many actions. These can be things like what values to set when updating a record, `db.users.update({name:'Roger'}, {$set: {has_beard:false} })`, or for setting more conditions around matches like checking if a value is greater than something, `db.users.find({age: {$gt: 21} })`

One final difference to mention is that MongoDB can store nested documents within other nested documents that are all fully queryable and editable. This can be a powerful way to store and manage simple, hierarchical data. But it becomes very complex if data needs to relate to multiple parents or if the nesting becomes very deep.

**EXERCISE** Manually run five different operations for each CRUD action for a collection in the mongo CLI.

## Monk

When using MongoDB in our Express applications, we'll use a simple driver to interface with the database server called Monk. Install and manage with NPM just like you would any other package. Note that Monk's documentation is pretty light because it is really just a JS driver for Mongo, kinda like PG for PostgreSQL. For advanced features, refer directly to the Mongo docs.

Often when people use MongoDB, they use a different driver like Mongoose, in their application. Mongoose is powerful and has many features, but it reolves around setting up object schemas and mapping how different schemas can relate to one another. It can also validate your data to ensure it matches the schema and the rules specified. Basically, Mongoose emulates in application code all the logic that would be managed by a relational DB.

**EXERCISE** Create a new API for Monday's pirate app (or at least a new branch in the same project) that utilizes MongoDB instead of PostgreSQL to work with data. What are some of the things that Mongo makes easier? What are some of the problems you're running into? If you have problems doing anything with MongoDB via Monk, make sure you still have `mongod` running.



## Resources

- [SQL to MongoDB mapping chart](https://docs.mongodb.com/manual/reference/sql-comparison/)
- [Why not to use MongoDB](http://cryto.net/~joepie91/blog/2015/07/19/why-you-should-never-ever-ever-use-mongodb/)
