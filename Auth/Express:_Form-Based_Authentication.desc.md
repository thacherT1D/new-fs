# Authentication Introduction

## Objectives

* Explain why storing a password in plain text is never acceptable and highly dangerous
* Describe what hashing and salting are	
* Explain how salting protects from lookup/dictionary table attacks
* Store passwords securely using the bcrypt module
* Utilize sessions to persist logged in user data

#### Storing passwords

One of the __worst__ possible things you can do as a developer is store a password in plain text. This means that when you take a password from a form you never want it to be stored so that someone can easily see it. Imagine if someone gets access to your database and can see every single password for all of your users. On top of that, most users have the same password for multiple sites<sup id="a1">[1](#f1)</sup> so a password on one site can very possibly be the same for many other ones. So long story short - __NEVER STORE PASSWORDS IN PLAIN TEXT!__

#### Basic encryption - one way vs two way.

So how do we store passwords? We encrypt them. Before we talk about how that's done, let's examine different forms of encryption.

- Two way encryption - think of something like gibberish or pig latin or even a simple code that you made up with a friend to send a secret message. The important thing here is that both parties know how to decipher a message. This is easy to use, but imagine if someone else gets access to the key or knows how to decipher the code. This is why we don't use two way encryption for passwords. The only person who should ever know their password is the person who created it, so we need a different way, so we use one way encryption.

- One way encryption - this is how we store passwords. This method also known as hashing and it allows text to be deciphered __only__ by the person who knows the original text. For a password this is perfect. As developers we shouldn't know, or be able to figure out, our users' passwords. If, for some reason they forget their password, we just send a link to reset it - we never want to just give back their password in plain text. 

#### bcrypt
<a href="https://www.npmjs.com/package/bcrypt" target="_blank">Docs: bcrypt</a>

The tool we use to hash passwords is called bcrypt. Bcrypt is a module based on the <a href="https://en.wikipedia.org/wiki/Blowfish_(cipher)" target="_blank">blowfish cipher</a>. To install it we use `npm install --save bcrypt` and make sure to add `const bcrypt = require('bcrypt');` when we want to use it in our code. Bcrypt provides functions for hashing, salting and comparing passwords.

### More on bcrypt:
[bcrypt Wiki](https://en.wikipedia.org/wiki/Bcrypt)

How it works:
 
- Generate a random salt<sup id="a2">[2](#f2)</sup>
- Collect a password.
- Generate a hashed version of a string that is a concatenation of the salt & the password entered by a user.
- Store the cost, salt, and cipher text. Because these three elements have a known length, it's easy to concatenate them and store them in a single field, yet be able to split them apart later.

When someone tries to authenticate, retrieve the stored cost and salt. Concatenate the salt onto the user entered password. Encrypt this string using the associated cost factor. If the generated cipher text matches the stored cipher text, the password is a match.

Stored in the database, a bcrypt "hash" might look something like this:

`$2a$10$vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa`

- 2a identifies the bcrypt algorithm version that was used.
- 10 is the cost factor; 2^10 iterations of the key derivation function are used.
- vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa is the salt and the cipher text, concatenated and encoded in a modified Base-64. The first 22 characters decode to a 16-byte value for the salt. The remaining characters are cipher text to be compared for authentication.
- $ are used as delimiters for the header section of the hash.

The bcrypt utility does not maintain a list of salts. Rather, salts are generated randomly and appended to the output of the function so that they are remembered later on. Put another way, the "hash" generated by bcrypt is not just the hash. Rather, it is the hash and the salt concatenated.

#### Salting

Not only is it important to hash a password, we need to add an additional layer of security and we do that by adding salt. Salting provides an extra hash at the end of our password which makes it much much more difficult for someone to crack our password using brute force (trying again and again) or a lookup table.

You can read more about this here: https://crackstation.net/hashing-security.htm.

If you STILL want to read more about bcrypt and salting, http://dustwell.com/how-to-handle-passwords-bcrypt.html is a fantastic article as well.

Let's talk through some examples of how salting actually works:

```javascript
const md5 = require('md5');
const u = require('underscore');
const crypto = require('crypto');
const users = [];

function create(email, password) {
  const salt = crypto.randomBytes(Math.ceil(10/2)).toString('hex').slice(0,10);
  const encrypted = md5(salt + password);
  users.push({email: email, password: encrypted + "$" + salt});
}

function createWithoutSalt(email, password) {
  users.push({email: email, password: md5(password) + '$'})
}

function verify(email, password) {
  const user = u.find(users, {email: email});
  const passwordParts = user.password.split('$');
  const salt = passwordParts[1];
  const encryptedToken = passwordParts[0];
  return (md5(salt + password) == encryptedToken);
}

create('chris@galvanize.com', 'password');
createWithoutSalt('nosalt@galvanize.com', 'password');
createWithoutSalt('nosalt2@galvanize.com', 'password');
console.log(users);
console.log(verify('chris@galvanize.com', 'password'));
console.log(verify('nosalt@galvanize.com', 'password'));
console.log(verify('nosalt2@galvanize.com', 'password'));
```

#### Authentication

One of the most important concepts in building an application is authentication - the process of ensuring that our users are valid (actually exist in our database, are who they say they are). Imagine if you could access a banking website and see your account without logging in, that would be pretty disasterous because anyone would have access to it. By authenticating our users, we can make sure that only the right users have access to the right pages.

### Adding Authentication Logic to Our Model

We're going to take an example [app](https://github.com/gSchool/form-based-auth) and add some real authentication to it.

Take a second to get this app setup locally, and see how it's working. It currently allows users to sign in, but it doesn't seem to care much whether or not it's a valid email / password. We're going to change that.

#### Step 1

First, we need to actually create users in the database. When we're doing that, we're also going to use bcrypt to safely store the user's password.

We're also going to take this opportunity to decouple our _model_ logic and our _route_ logic.

Let's open up the `models/users.js` file and add some things to it. We're going to add a lot of code, but really all we're doing is generating a _salt_, and _hashing_ the user's password and the salt together, and then setting the resulting value to the `password_digest` property. Then we can create our user. The end result of our file will look like this:

```javascript
const knex = require('../db/knex');
const bcrypt = require('bcrypt');
const SALT_WORK_FACTOR = 10;

function Users() {
  return knex('users');
}

Users.createUser = (data, callback) => {
  bcrypt.genSalt(SALT_WORK_FACTOR, (err, salt) => {
    if (err) {
      callback(err);
    }

    bcrypt.hash(data.password, salt, (err, hash) => {
      if (err) {
        callback(err);
      }

      data.password_digest = hash;
      delete data.password;
      Users().insert(data, '*').then((data) => {
        callback(undefined, data);
      });
    });
  });
}

module.exports = Users;
```

And now, we need to tweak our `routes/users.js` file to actually use this new function we've created:

```javascript
router.post('/', (req, res, next) => {
  Users.createUser(req.body, (err, data) => {
    res.send(data);
  });
});
```

Now, if you go to create a user in the web browser, you should see that it functions and that we're generating a `password_digest` that looks similar to how we've described it earlier.

We still can't login as a user, though, so let's work on that next.

#### Step 2

Let's add a function to our `models/users.js` file that let's us verify the email and password combo.

```javascript
Users.authenticateUser = (email, password, callback) => {
  Users().where({email: email}).first().then(user => {
    if (!user) {
      return callback("Email and password don't match");
    }
    bcrypt.compare(password, user.password_digest, function(err, isMatch) {
      console.log(err);
      if (err) {
        return callback("Email and password don't match");
      } else {
        return callback(undefined, user);
      }
    });
  });
}
```

Next up, we will change our `POST /signin` route to utilize this new function:

```javascript
router.post('/signin', (req, res, next) => {
  Users.authenticateUser(req.body.email, req.body.password, (err, user) => {
    if (err) {
      res.render('auth/signin.ejs', {error: err});
    } else {
      req.session.user = user;
      res.redirect('/');
    }
  });
});
```

We should now be able to login with any user accounts we've created.

### Understanding cookies + sessions

### What are sessions?

Sessions are used to store data about a user on the server. This can be an authenticated user or a non-authenticated user. Session data can be stored in a database or in the cookie itself. In the example we're working with here all the data about the session is stored directly in the cookie itself. This does mean that there is a limit to how much data we can store in the session. Cookies are limited to only 4kb (generally, it varies by browser) in total size. If you need to store more data than this in the session, then you'll need to look at storing the session in the database. [Sessionstore](https://www.npmjs.com/package/sessionstore) is an example of a piece of middleware that can be used to store the session data like that.

It's important to note that even if you're storing the _session_ data in a database that it will still rely on a cookie. In this case, the cookie would just contain a unique identifier that will allow the server to fetch the session data from the database instead of from the cookie directly.

### What are cookies?

Cookies are bits of data that are key / value pairs that are (usually) set to expire at either a specific time, or when the browser is closed. These are just plain text that's readable by anyone. If you open up the chrome developer tools, you'll see a cookies tab that has information about the cookies that are being sent to this site. All cookies are associated with a `domain` so that the browser knows which websites to send cookies to. All requests to that domain will send all of the cookies that the browser has that match that domain.

### Using sessions in express

The example code we added authentication to was already setup to use sessions, but if you look over at `app.js`, you'll see the following lines:

```javascript
const cookieParser = require('cookie-parser');
const session = require('cookie-session');

app.use(cookieParser());
app.use(session({keys: [process.env.SESSION_KEY1, process.env.SESSION_KEY2]}));
```

Since we're using a `cookie` to store the session in, we'll need both a cookie-parser middleware as well as a piece of middleware for the session handling itself. This will create a `req.session` object that we can use to persist data to.

Like everything in Express, the order of things really matters here. You'll need to have your `cookieParser` middleware before your `session` middleware, or it won't work right. When you're modifying the `req.session` object, you need to make sure you do that before you send the response to the browser. Since we're storing all the session data in the cookie itself, we need to send that information back to the browser in the response.

- <span id="f1">https://lastpass.com/</span> [↩](#a1)
- https://agilebits.com/onepassword [↩](#a1)
- <span id="f2">https://en.wikipedia.org/wiki/Salt_(cryptography)</span> [↩](#a2)

## Videos

These videos mostly use Mongo as the database, so the code won't directly correlate to the things we've been talking about. They're a good resource if you'd like to hear another way of describing these techniques.

### Video #1 - Authentication Overview

<iframe src="https://player.vimeo.com/video/141225092?byline=0&portrait=0" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

This video is a great overview of how authentication is done in express.js. This video uses a different persistence layer, but the logic remains the same no matter what persistence layer you use. [Take a look at this example](https://github.com/gSchool/form-auth-with-express-knex-pg-bcrypt) for one using a more familiar persistence layer.

### Video #2 - Cryptographic Hashing

<iframe src="https://player.vimeo.com/video/141284905?byline=0&portrait=0" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

How do we secure our user data? Knowing this basic information well will put you above most developers in terms of security knowledge (unfortunately). Pay close attention to the information in this video, or you might cause your new employer to [show up on this list](https://haveibeenpwned.com/PwnedWebsites).  

### Video #3 - Cookies

<iframe src="https://player.vimeo.com/video/141304889?byline=0&portrait=0" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

## Video #4 - Sessions

<iframe src="https://player.vimeo.com/video/141306923?byline=0&portrait=0" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
