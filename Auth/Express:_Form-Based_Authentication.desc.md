# Class Example 

https://github.com/gSchool/mongoose_auth_example

# Authentication Introduction

# Objectives

* Explain why storing a password in plain text is never acceptable and highly dangerous
* Understand what hashing and salting are	
* Explain how salting protects from lookup/dictionary table attacks
* Store passwords securely using the bcrypt module

### Key terms and technologies

#### Storing passwords

One of the __worst__ possible things you can do as a developer is store a password in plain text. This means that when you take a password from a form you never want it to be stored so that someone can easily see it. Imagine if someone gets access to your database and can see every single password for all of your users. On top of that, most users have the same password for multiple sites<sup id="a1">[1](#f1)</sup> so a password on one site can very possibly be the same for many other ones. So long story short - __NEVER STORE PASSWORDS IN PLAIN TEXT!__

#### Basic encryption - one way vs two way.

So how do we store passwords? We encrypt them. Before we talk about how that's done, let's examine different forms of encryption.

- Two way encryption - think of something like gibberish or pig latin or even a simple code that you made up with a friend to send a secret message. The important thing here is that both parties know how to decipher a message. This is easy to use, but imagine if someone else gets access to the key or knows how to decipher the code. This is why we don't use two way encryption for passwords. The only person who should ever know their password is the person who created it, so we need a different way, so we use one way encryption.

- One way encryption - this is how we store passwords. This method also known as hashing and it allows text to be deciphered __only__ by the person who knows the original text. For a password this is perfect. As developers we shouldn't know, or be able to figure out, our users' passwords. If, for some reason they forget their password, we just send a link to reset it - we never want to just give back their password in plain text. 

#### bcrypt
<a href="https://www.npmjs.com/package/bcrypt" target="_blank">Docs: bcrypt</a>

The tool we use to hash passwords is called bcrypt. Bcrypt is a module based on the blowfish cipher. To install it we use `npm install --save bcrypt` and make sure to add `const bcrypt = require('bcrypt');` when we want to use it in our code. Bcrypt provides functions for hashing, salting and comparing passwords.

### More on bcrypt:
<a href="https://en.wikipedia.org/wiki/Bcrypt" target="_blank">bcrypt Wiki</a>

How it works:
 
- Generate a random salt<sup id="a2">[2](#f2)</sup> (A "work" factor has been pre-configured.)
- Collect a password.
- Generate a hashed version of a string that is a concatenation of the salt & the password entered by a user.
- Store the cost, salt, and cipher text. Because these three elements have a known length, it's easy to concatenate them and store them in a single field, yet be able to split them apart later.

When someone tries to authenticate, retrieve the stored cost and salt. Concatenate the salt onto the user entered password. Encrypt this string using the associated cost factor. If the generated cipher text matches the stored cipher text, the password is a match.

Stored in the database, a bcrypt "hash" might look something like this:

`$2a$10$vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa`

- 2a identifies the bcrypt algorithm version that was used.
- 10 is the cost factor; 2^10 iterations of the key derivation function are used.
- vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa is the salt and the cipher text, concatenated and encoded in a modified Base-64. The first 22 characters decode to a 16-byte value for the salt. The remaining characters are cipher text to be compared for authentication.
- $ are used as delimiters for the header section of the hash.

The bcrypt utility does not maintain a list of salts. Rather, salts are generated randomly and appended to the output of the function so that they are remembered later on. Put another way, the "hash" generated by bcrypt is not just the hash. Rather, it is the hash and the salt concatenated.

#### Salting

Not only is it important to hash a password, we need to add an additional layer of security and we do that by adding salt. Salting provides an extra hash at the end of our password which makes it much much more difficult for someone to crack our password using brute force (trying again and again) or a lookup table.

You can read more about this [here](https://crackstation.net/hashing-security.htm)

If you STILL want to read more about bcrypt and salting, [this](http://dustwell.com/how-to-handle-passwords-bcrypt.html) is a fantastic article.

```javascript
const md5 = require('md5');
const u = require('underscore');
const crypto = require('crypto');
const users = [];

function create(email, password) {
  const salt = crypto.randomBytes(Math.ceil(10/2)).toString('hex').slice(0,10);
  const encrypted = md5(salt + password);
  users.push({email: email, password: encrypted + "$" + salt});
}

function createWithoutSalt(email, password) {
  users.push({email: email, password: md5(password) + '$'})
}

function verify(email, password) {
  const user = u.find(users, {email: email});
  const passwordParts = user.password.split('$');
  const salt = passwordParts[1];
  const encryptedToken = passwordParts[0];
  return (md5(salt + password) == encryptedToken);
}

create('chris@galvanize.com', 'password');
createWithoutSalt('nosalt@galvanize.com', 'password');
createWithoutSalt('nosalt2@galvanize.com', 'password');
console.log(users);
console.log(verify('chris@galvanize.com', 'password'));
console.log(verify('nosalt@galvanize.com', 'password'));
console.log(verify('nosalt2@galvanize.com', 'password'));
```

#### Authentication

One of the most important concepts in building an application is authentication - the process of ensuring that our users are valid (actually exist in our database). We only want to grant access to certain pages for users who are not logged in. Imagine if you could access a banking website and see your account without logging in....that would be pretty disasterous because anyone would have access to it. By authenticating our users, we can make sure that only the right users have access to the right pages. Another example to think about would be if other facebook users could have access to __your__ settings page...that would be quite bad.

### Adding Authentication Logic to Our Model

##### Step 1
```
var mongoose = require("mongoose");
var bcrypt = require("bcrypt";);
var SALT_WORK_FACTOR = 10;
```
 
##### Step 2
```
var UserSchema = new Schema({
  username: { 
    type: String, 
    required: true
  },
  password: { 
    type: String, 
    required: true 
  }
});
```

##### Step 3
``` 
UserSchema.pre(save, function(next) {
  var user = this;
 
  // only hash the password if it has been modified (or is new)
  if (!user.isModified('password')) return next();
 
  // generate a salt
  bcrypt.genSalt(SALT_WORK_FACTOR, function(err, salt) {
    if (err) return next(err);
 
    // hash the password using our new salt
    bcrypt.hash(user.password, salt, function(err, hash) {
      if (err) return next(err);
 
      // override the cleartext password with the hashed one
      user.password = hash;
      next();
    });
  });
});
```

##### Step 4

``` 
UserSchema.methods.comparePassword = function(candidatePassword, cb) {
  bcrypt.compare(candidatePassword, this.password, function(err, isMatch) {
    if (err) return cb(err);
    cb(null, isMatch);
  });
};
``` 

##### Step 5 

```
var User = mongoose.model('User', UserSchema);
module.exports = User;
```

### Understanding cookies + sessions

###What are sessions?

Sessions are used to store data about a user on the server. This can be an authenticated user or a non-authenticated user. Session data is stored on the server for each person using the website and referenced using a cookie stored on the users computer. The session cookie contains a unique key that allows the server to access the correct data for each person.

### What are cookies?

# rewrite:

Cookies are essentially small text files, given ID tags that are stored on your computer's browser directory or program data subfolders. Cookies are created when you use your browser to visit a website that uses cookies to keep track of your movements within the site, help you resume where you left off, remember your registered login, theme selection, preferences, and other customization functions. The website stores a corresponding file(with same ID tag)to the one they set in your browser and in this file they can track and keep information on your movements within the site and any information you may have voluntarily given while visiting the website, such as email address.

###Why is this useful?

Session data is retained between page loads so it allows sharing of data between requests without passing it in the url string. Sessions are also integral for user authentication.

###Using sessions in express

In express to utilize sessions we need to load the session middleware. The setup is pretty simple and very similar to setting up the body-parser middleware. We'll see this in the class example.

- <span id="f1">https://lastpass.com/</span> [↩](#a1)
- https://agilebits.com/onepassword [↩](#a1)
- <span id="f2">https://en.wikipedia.org/wiki/Salt_(cryptography)</span> [↩](#a2)


How often will you implement authentication from scratch in a job?  Not often, at least as a junior developer.

So why do we teach it?  Because it touches on a number of *hugely* important topics and challenges you to combine them with things you already know.  Things you'll touch on while learning to implement form-based authentication are:

- CRUD (creating users)
- Validations (displaying error messages like "invalid email / password")
- Cryptographic hashing
- Cookies and sessions

You will need to watch all of these videos in order to understand the concepts at play when we do authentication.

## Video #1 - Authentication Overview

<iframe src="https://player.vimeo.com/video/141225092?byline=0&portrait=0" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

This video is a great overview of how authentication is done in express.js. This video uses a different persistence layer, but the logic remains the same no matter what persistence layer you use. [Take a look at this example](https://github.com/gSchool/form-auth-with-express-knex-pg-bcrypt) for one using a more familiar persistence layer.

#### Resources

- [Form Authentication with Express, Knex, pg and Bcrypt](https://github.com/gSchool/form-auth-with-express-knex-pg-bcrypt)

## Video #2 - Cryptographic Hashing

<iframe src="https://player.vimeo.com/video/141284905?byline=0&portrait=0" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

How do we secure our user data? Knowing this basic information well will put you above most developers in terms of security knowledge (unfortunately). Pay close attention to the information in this video, or you might cause your new employer to [show up on this list](https://haveibeenpwned.com/PwnedWebsites).  

#### Resources

- https://crackstation.net/hashing-security.htm
- http://codahale.com/how-to-safely-store-a-password/
- http://www.unlimitednovelty.com/2012/03/dont-use-bcrypt.html
- https://blog.agilebits.com/2015/03/30/bcrypt-is-great-but-is-password-cracking-infeasible/
- https://www.owasp.org/index.php/Main_Page

## Video #3 - Cookies

<iframe src="https://player.vimeo.com/video/141304889?byline=0&portrait=0" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

Let's practice what we just learned. **Do this, because we're going to build on it after the next video**. 

Create a new directory, and generate an express app with `express cookieExample`. Then `git init` in that folder, of course. Add `node_modules` to your `.gitignore`, and then `npm install`. Then, commit all files.  

The express generator installs the `cookie-parser` module for you already, and you can find it being added to your app on **line 22**.  

In your `./routes/index.js` file, we're going to set a cookie, and then read that cookie.

```javascript
router.get('/', function(req,res,next){
	res.cookie('views',parseInt(req.cookies.views || 0) + 1);

	res.render('index', { title: 'Express', views: (req.cookies.views || 0)});
});

```

Then, go to your `./views/index` and add the `views` variable to your template.

***Jade***
```
p You have been to this page #{views} times.
```

***EJS***
```
<p>You have been to this page <%=views%> times.</p>
```

Now, using the instructions in the video above, **do the following**:

- Using `res.clearCookie()`, create a route, and link on the homepage, that clears that cookie, then redirects the user back to the homepage.

- Upgrade your cookies to be more secure, by ensuring they are *signed*, *secure*, and *http only*.


#### Resources

- https://en.wikipedia.org/wiki/HTTP_cookie
- https://www.npmjs.com/package/cookie


## Video #4 - Sessions

<iframe src="https://player.vimeo.com/video/141306923?byline=0&portrait=0" width="500" height="375" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

Now we're going to use the techniques described in the above video to use sessions instead of cookies.

Open up the project we generated after the Cookies video.

First, `npm install cookie-session`. Then require it in your `app.js` file.

* Put the `cookieSession` middleware in your app.
* Configure the `cookieSession` middleware by giving it a `name` key, and adding some keys to the `keys` array.
* Change all references to `req.cookies` or `res.setCookie()` to use the `req.session` object instead.
* Get your keys from your `.env` file, instead of comitting them to your code.


#### Resources

Generating random strings in Node:

```
node -e "require('crypto').randomBytes(48, function(ex, buf) { console.log(buf.toString('hex')) });"
```

- [Cookie Sessions](https://github.com/expressjs/cookie-session)

## Examples

[Form-based Authentication with `pg` and `knex`](https://github.com/gSchool/form-auth-with-express-knex-pg-bcrypt/)


## Assignment
This assignment should take you about 2 hours to complete.  

[Express Authentication with Forms](https://github.com/gSchool/authentication-in-express)

## Reflect

### Self-Assessment

How’d you do? Go back to the "Objectives" section. Go through each one and ask yourself:

- Have I completed this objective?
- What concrete evidence do I have that I've completed the objective?

Rate yourself 1 through 4 for each objective in terms of competence (4 being the highest). If you rate yourself a 2 or below, please notify an instructor for additional help.

Go to the "Key Terms" section.  For each term, ask yourself:

- What is my explanation for this term?

If you haven't completed an objective, or you can't define a term, take a few minutes to try to fill in any gaps.
