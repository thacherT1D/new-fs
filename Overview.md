## WDI Overview

![](https://students-gschool-production.s3.amazonaws.com/uploads/asset/file/379/wdi-curriculum-overview.png)

### Solving Problems

If you interview at Google one of the first things the recruiter will tell you is that Google's process is designed to assess your problem solving abilities.

To start, it's important to know that your problem solving abilities are not some fixed attribute that you were born with.  Just like playing an instrument, or a sport, or a game like chess, becoming a problem solver is a skill, and it's a skill that you can improve through focused practice.

When developers say that you need to be a good problem solver what they're typically talking about, at a high level, is being able to **turn words into working software**.  For example someone might say they want to build "Netflix for clothing" - just 3 simple words might take months or years to solve, and will involve thousands and thousands of smaller problems.

In 1945 the mathematician George Pólya elegantly described these common steps in a book called "How to Solve It".  He identified the four steps as:

1. Understanding the problem
1. Devising a plan
1. Carrying out the plan and
1. Looking back

Alone these 4 steps might not seem very helpful or actionable, throughout the course you'll learn how these can guide your development.

We've come up with a set of concrete, measurable skills, both technical and behavioral, for each step of this problem-solving process.

1. Understand the problem
  1. Identify inputs and outputs
  1. Ask "What if?" questions to discover edge cases
1. Devise a solution
  1. Come up with more than one potential solution
  1. Choose a solution based on:
    - Performance (time and space complexity)
    - Maintainability
    - Your ability to code it
1. Carry out the solution
  1. Dispense with boilerplate code
  1. Code "outside in"
1. Look back
  1. Ensure correctness
  1. Look for opportunities to refactor
    - Check for DRY
    - Check for SOLID

And the wonderful thing about learning these problem solving techniques is that they are both _cyclical_ and _fractal_.  That means you'll use them a _lot_.  When you start a project, you might run through the 4 steps over the course of weeks or months.  Then when you are focusing on any individual feature of the app, you may run through the steps in hours or days.  And when writing a single unit test you may run through the steps in a matter of minutes.

![](https://students-gschool-production.s3.amazonaws.com/uploads/asset/file/380/polya-fractal.png)

As you can see, Polya's problem solving techniques play a foundational role in your journey to becoming a developer.

### Getting Things Done (being productive)

Being consistently productive is a skill, and just like any other skill, you can learn it through focused practice.  In this program you'll learn a host of techniques to help you sustainably deliver high quality code.  These techniques fall roughly into 2 categories:

- agile development
- good developer workflows / tools

**Agile Development**

Agile development is a process for building applications designed to make it easy to change your app based on feedback from users.  If you understand agile development practices you will become a more productive developer.

We can define "productive developer" as one who frequently solves a problem a user has _and_ gets that code out into a production application with a _steady velocity_.  In other words, a productive developer is one who consistently and predictably ships working software.

In order to ship working software, you often need to do a _little bit_ of every aspect of the website (HTML / CSS / server-side code, database tables, deployment etc...).  You build your application in slices.  If you follow the rule of ["half but not half-assed"](https://gettingreal.37signals.com/ch05_Half_Not_Half_Assed.php) you'll be able to get your software into the hands of users.

**Good Developer Workflow**

Part of being a productive developer is just being fast at things.  This can come from the simple, obvious things like typing fluently, but also comes from:

- Understanding how to debug code quickly (stack traces, debuggers etc...)
- Write code "outside in" so you can follow error messages
- Use Git effectively so you can take risks and experiment without losing work
- Writing automated tests so you can run through the Polyá steps efficiently
- Being a power user of your machine (understanding package management, command line tools etc...)

### Learning New Things

Learning is itself a skill, and it's a skill that you can improve on with focused practice.  At Galvanize, there are two main ways you'll improve as a learner by adopting **a set of habits and mindsets** and learning **common software patterns**.

First, you'll learn a process that will set you up for success when approaching a new topic.  We call this "Learning to Learn", and it's so important that it's one of the first lessons we teach.  It's designed to help you develop habits and mindsets that will allow you to methodically navigate the ever-changing tech landscape.

1. Set the stage
  1. Clear the stage
  1. Clarify the "what" and "why" (the objectives)
1. Play
  1. Take risks
  1. Wrestle with it / have a growth mindset
1. Reflect
  1. Self-assess (how did you do relative to the objectives)
  1. Ask new questions

Of course a few behavior changes alone won't be enough to learn new technologies as fast as you'll need to.  In order to truly learn new things quickly you'll need to have a well-chunked, 3D mental model of several common software patterns, and be able to match those to new information so you can incorporate new information into your existing mental structure.

These patterns include everything from algorithm patterns like accumulators and recursive patterns to larger application patterns such as validation, routing and template rendering.  When learning these concepts, you'll learn two parts:  the pattern itself, _and_ a specific implementation of that pattern.

If you know how to efficiently approach new subjects, _and_ you have a rich set of pre-existing mental structures to attach the new information to, you'll be unstoppable.

Some patterns are:

- Code
  - Accumulator pattern
  - Recursive iteration (first/rest)
  - Recursing over a tree
  - OOP
  - Dependency Injection
- Apps
  - Routing
  - Validation
  - Associations
  - Model-View-Controller
  - Input-Transform-Output Pattern
  - Authentication and Authorization
  - REST
  - CRUD
  - Persistence
